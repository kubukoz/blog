<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.kubukoz.com</title>
   
   <link>https://blog.kubukoz.com</link>
   <description>A blog about functional programming, and programming in general</description>
   <language>en-us</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Learning vim by blogging</title>
	  <link>//learning-vim-by-blogging</link>
	  <author></author>
	  <pubDate>2019-04-30T12:00:00+00:00</pubDate>
	  <guid>//learning-vim-by-blogging</guid>
	  <description><![CDATA[
	     <p>I decided that writing about something is one of the easiest ways to learn it for a longer period of time. In this blog post, which I hope to update once in a while, I’ll be sharing my findings about Vim (neovim).</p>

<p>This post will be written exclusively in (variants of) Vim.</p>

<h2 id="go-to-the-nextprevious-occurrence-of-a-character">Go to the next/previous occurrence of a character</h2>

<p>To go to the next occurrence of a character, use <code class="highlighter-rouge">t</code> (sets the cursor before the character) or <code class="highlighter-rouge">f</code> (on the character). To find the previous one, use <code class="highlighter-rouge">T</code> (after the character) or <code class="highlighter-rouge">F</code> (on the character).</p>

<p>For example, in this line:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span> <span class="k">=</span> <span class="n">bar</span><span class="o">&lt;</span><span class="n">cursor</span><span class="o">&gt;</span> <span class="o">+</span> <span class="mi">5</span>
</code></pre></div></div>

<p>If I want to select <code class="highlighter-rouge">= bar</code> (space included), I can press <code class="highlighter-rouge">F=</code>.</p>

<h2 id="copypaste-to-clipboard">Copy/paste to clipboard</h2>

<p>To copy to the buffer inside Vim, you press <code class="highlighter-rouge">y</code> after selecting some text. To copy it to the clipboard, you use <code class="highlighter-rouge">"*y</code>. Similarly with <code class="highlighter-rouge">p</code> for pasting.</p>

<h2 id="go-to-firstlast-line-of-file">Go to first/last line of file</h2>

<p>Press <code class="highlighter-rouge">gg</code> / <code class="highlighter-rouge">G</code>.</p>

<h2 id="go-to-beginningend-of-line">Go to beginning/end of line</h2>

<p>Press <code class="highlighter-rouge">^</code> / <code class="highlighter-rouge">$</code>.</p>

<p><code class="highlighter-rouge">g_</code> moves you to the last non-blank character.</p>

<p><code class="highlighter-rouge">A</code> moves you to the end of the line and switches to editing (A as in Append), to do the same at the beginning use <code class="highlighter-rouge">I</code>.</p>

<hr />

<h2 id="links">Links</h2>

<p><a href="https://www.cyberciti.biz/faq/howto-unix-linux-vi-vim-jump-to-end-of-file/">vi / vim: Jump To End Of File Command</a></p>

<p><a href="https://stackoverflow.com/questions/2332513/vim-select-to-character-non-inclusive">vim: select to character, non-inclusive</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Data coherence at large</title>
	  <link>//data-coherence-at-large</link>
	  <author></author>
	  <pubDate>2019-04-14T16:00:00+00:00</pubDate>
	  <guid>//data-coherence-at-large</guid>
	  <description><![CDATA[
	     <p>A week ago, while coming back from <a href="http://scalar-conf.com">Scalar</a>, I was thinking about coherent data. In particular, I was wondering if it’s possible to perform certain simple validations and encode their results in types. Here’s what i found.</p>

<h2 id="what-is-coherent-data"><a href="#what-is-coherent-data">What is coherent data</a></h2>

<p>The concept of coherent data was introduced to me when I watched <a href="https://www.youtube.com/watch?v=gVXt1RG_yN0">Daniel Spiewak’s talk about coherence</a>. Data coherence is achieved when we have a single source of truth about our data. Let’s look at an example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"Rachel"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="k">if</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="s">"default"</span>
  <span class="k">else</span> <span class="n">name</span><span class="o">.</span><span class="n">get</span>
</code></pre></div></div>

<p>In this code we don’t have any sort of coherence in the data. One condition that we check - the emptiness of <code class="highlighter-rouge">name</code> - gives us information that is immediately lost in the rest of the code. Even if we’ve checked for the emptiness and are sure that the Option isn’t empty, there’s nothing in the type system or any other feature of the language that would tell us whether we can call <code class="highlighter-rouge">Option#get</code> on it safely. We only know that because we keep in mind that we’ve already checked for the emptiness ourselves.</p>

<p>Another example involves lists:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">names</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Phoebe"</span><span class="o">,</span> <span class="s">"Joey"</span><span class="o">,</span> <span class="s">"Ross"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">firstNameLength</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">None</span>
  <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
</code></pre></div></div>

<p>Even though we’ve checked for the list’s emptiness, we still have no guarantee that <code class="highlighter-rouge">head</code>, which is in general not a safe method to call on a list, won’t throw an exception.</p>

<p>There’s no connection between <code class="highlighter-rouge">isEmpty</code> and <code class="highlighter-rouge">head</code>/<code class="highlighter-rouge">get</code> enforced by the compiler. It’s just incapable of helping us avoid mistakes like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="c1">//boom!
</span></code></pre></div></div>

<p>Is this the way it’s meant to be? Is it possible to make the compiler work with us to ensure some guarantees about our data?</p>

<p>In Kotlin, another language that works on the JVM (mostly), there is a feature that solves this particular problem we had with Option: <a href="https://kotlinlang.org/docs/reference/typecasts.html#smart-casts">smart casts</a>. But the feature is limited to checking types or nullity, while we’re looking for something that’ll work in the general case.</p>

<p>Thankfully, there’re features in Scala that allow us to reason about our data as coherent: pattern matching and higher-order functions.</p>

<h2 id="data-coherence-with-pattern-matching"><a href="#data-coherence-with-pattern-matching">Data coherence with pattern matching</a></h2>

<p>Let’s rewrite the examples from the previous section using pattern matching:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"Rachel"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">name</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">None</span>    <span class="k">=&gt;</span> <span class="s">"default"</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">v</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Much better - now we managed to get both the emptiness check and the extraction in one go (in the pattern match). We’re not calling any unsafe methods, and we get additional help from the compiler in the form of exhaustivity checking. What about lists?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">names</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"Phoebe"</span><span class="o">,</span> <span class="s">"Joey"</span><span class="o">,</span> <span class="s">"Ross"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">firstNameLength</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">names</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Nil</span>            <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="n">firstName</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">firstName</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Again, we’re not calling <code class="highlighter-rouge">head</code> or any other unsafe method. And the check is again combined with the extraction in a single pattern match.</p>

<p>I mentioned higher-order functions, so what about them? Turns out that pattern matches (and functions implemented using them) can often be rewritten using a single call to <code class="highlighter-rouge">fold</code> for the given data type. It’s more obvious in the case of Option:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"Rachel"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">name</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">"default"</span><span class="o">)(</span><span class="n">identity</span><span class="o">)</span>
</code></pre></div></div>

<p>Or <code class="highlighter-rouge">Either</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">NameNotFound</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Right</span><span class="o">(</span><span class="s">"Rachel"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">name</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">extractError</span><span class="o">,</span> <span class="n">identity</span><span class="o">)</span>
</code></pre></div></div>

<p>However, <code class="highlighter-rouge">fold</code> doesn’t appear to be the right choice if we only care about part of the data (like in the list example, where we only needed the head of the list). In that particular case, a good old <code class="highlighter-rouge">headOption</code> would work just fine.</p>

<h2 id="data-coherence-at-scale"><a href="#data-coherence-at-scale">Data coherence at scale</a></h2>

<p>This is all nice and pretty - the promise of having data that doesn’t require us to watch our backs every step we take sounds encouraging. But when the data is part of other data, things start to break very soon.</p>

<p>Suppose we’re working with a <code class="highlighter-rouge">User</code> class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>
</code></pre></div></div>

<p>Now imagine we want to run a code path only if the user has a <code class="highlighter-rouge">lastName</code> set. The caveat: we still want to pass the <code class="highlighter-rouge">User</code> instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">withValidatedUser</span><span class="o">(</span><span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">user</span> <span class="k">=</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Katie"</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"Bouman"</span><span class="o">))</span>

<span class="n">user</span><span class="o">.</span><span class="n">lastName</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">last</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">withValidatedUser</span><span class="o">(</span><span class="n">last</span><span class="o">,</span> <span class="n">user</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">None</span>       <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What’s the problem? Well, even though we did the validation in a coherent way using a pattern match, we lose the coherence inside <code class="highlighter-rouge">withValidatedUser</code>: <code class="highlighter-rouge">lastName</code> is now completely separated from the <code class="highlighter-rouge">User</code> object it came from. And now we have two <code class="highlighter-rouge">lastName</code>s: one optional, one required.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">withValidatedUser</span><span class="o">(</span><span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">((</span><span class="n">lastName</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="n">lastName</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is terrible news. It appears like we can’t maintain data coherence when the data is part of something else. Or can we?</p>

<p>Surely there are ways to get what we want - one of them is adding a new variant of the <code class="highlighter-rouge">User</code> class, but with a required <code class="highlighter-rouge">lastName</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">UserWithLast</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</code></pre></div></div>

<p>…but you can probably already imagine how much boilerplate it’d bring to your codebase if you needed a new class for every combination of optional fields if the <code class="highlighter-rouge">User</code> type had more than one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span>
  <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">lastName</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
  <span class="n">email</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">UserWithLastAndEmail</span><span class="o">(</span>
  <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">email</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">UserNoEmail</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">UserNoLast</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">email</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="o">...</span>
</code></pre></div></div>

<p>It doesn’t seem like a viable solution to the problem. In fact, it’d create more problems than it solved.</p>

<p>I entertained the idea that we could parameterize our original <code class="highlighter-rouge">User</code> with type parameters a bit:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">[</span><span class="kt">LastName</span><span class="o">](</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">LastName</span><span class="o">)</span>

<span class="c1">//just so that we have some distinction below
</span><span class="k">type</span> <span class="kt">LastName</span> <span class="o">=</span> <span class="nc">String</span>

<span class="k">def</span> <span class="n">withValidatedUser</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">LastName</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">val</span> <span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">LastName</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Katie"</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"Bouman"</span><span class="o">))</span>

<span class="c1">// try it at home: this could be a fold!
</span><span class="n">user</span><span class="o">.</span><span class="n">lastName</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">last</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">withValidatedUser</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">lastName</span> <span class="k">=</span> <span class="n">last</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">None</span>       <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now a few things happened:</p>

<ol>
  <li>We’re not passing the <code class="highlighter-rouge">lastName</code> value separately now</li>
  <li><code class="highlighter-rouge">lastName</code> being required is now a type-level prerequisite in <code class="highlighter-rouge">withValidatedUser</code></li>
  <li>We’re copying the <code class="highlighter-rouge">user</code> value with <code class="highlighter-rouge">lastName</code> substituted with the value extracted from <code class="highlighter-rouge">Option</code> using a pattern match</li>
  <li>We only have one data type that supports all combinations of emptiness/non-emptiness using type parameters.</li>
</ol>

<p>What does this give us?</p>

<p>We gained type safety in <code class="highlighter-rouge">withValidatedUser</code> - the function now can’t be called with a <code class="highlighter-rouge">User</code> whose <code class="highlighter-rouge">lastName</code> hasn’t been checked for non-emptiness. It just won’t compile if we pass an <code class="highlighter-rouge">Option</code> in that field. One less test case to worry about.</p>

<p>It’s also pretty interesting that we can now write functions that require the user to <strong>not</strong> have a second name:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">withInvalidUser</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span>
</code></pre></div></div>

<p>For me, the most surprising part here was that I couldn’t use <code class="highlighter-rouge">Nothing</code> as the type of <code class="highlighter-rouge">lastName</code> - which I wanted to do to guarantee that <code class="highlighter-rouge">lastName</code> just isn’t there. However, we can’t create values of type <code class="highlighter-rouge">Nothing</code>, and we can’t pass them as constructor parameters of a class. I used <code class="highlighter-rouge">Unit</code> instead, which is a type with only one value, which is obviously not the user’s last name. Creating a user with <code class="highlighter-rouge">LastName = Unit</code> is also very easy: <code class="highlighter-rouge">User("Joe",  ())</code>.</p>

<p>What’s the problem with the latest solution?</p>

<ol>
  <li>We made it more difficult to work with the User type - now everyone who uses that type needs to be aware that the <code class="highlighter-rouge">lastName</code> field is parameterized. And it’s viral - pretty soon all the codebase will be littered with type parameters irrelevant in these regions of code.</li>
  <li>We can insert any type we want as <code class="highlighter-rouge">LastName</code>. It could even be <code class="highlighter-rouge">IO[Unit]</code>. And it’s very easy to do so.</li>
</ol>

<p>Looks like we aren’t quite there yet. What can we do to make our type easier to work with?</p>

<h2 id="a-different-kind-of-coherence"><a href="#a-different-kind-of-coherence">A different kind of coherence</a></h2>

<p>Our original goal in the exercise was to encode validations and invariants of our data in the data’s type. Let’s get back to our <code class="highlighter-rouge">User</code> example. This time we’ll encode it using higher-kinded types (but with two “variable-effect” fields):</p>

<p>(if you’re not familiar with higher-kinded types, I suggest you <a href="https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html">check out some blog posts</a>. For now, it should be enough to know that a higher-kinded type is a type-level function, or a type that needs to be applied with another type to construct a fully concrete type that can be assigned to a value. For example <code class="highlighter-rouge">Option</code> needs an <code class="highlighter-rouge">A</code> to become <code class="highlighter-rouge">Option[A]</code>, a type that has values.</p>

<p>If we parameterize <code class="highlighter-rouge">User</code> with higher-kinded types, we get this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">[</span><span class="kt">LastName</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Email</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
  <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">lastName</span><span class="k">:</span> <span class="kt">LastName</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
  <span class="n">email</span><span class="k">:</span> <span class="kt">Email</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span>
</code></pre></div></div>

<p>Cool. How do we create a <code class="highlighter-rouge">User</code> with all fields optional now?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">jon</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Option</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">User</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Option</span><span class="o">](</span><span class="s">"Jon"</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"Snow"</span><span class="o">),</span> <span class="nc">None</span><span class="o">)</span>
</code></pre></div></div>

<p>How do we create one with some fields required?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// old trick from scalaz/cats/shapeless
</span><span class="k">type</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span>

<span class="k">val</span> <span class="n">jon</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Option</span><span class="o">]</span> <span class="k">=</span> <span class="nc">User</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Option</span><span class="o">](</span><span class="s">"Jon"</span><span class="o">,</span> <span class="s">"Snow"</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>
</code></pre></div></div>

<p>Also cool. We can’t assign <code class="highlighter-rouge">None</code> as the value of <code class="highlighter-rouge">lastName</code> if <code class="highlighter-rouge">LastName</code> is <code class="highlighter-rouge">Id</code>. How would we encode the requirement that there’s no email now?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Void</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Unit</span>

<span class="k">val</span> <span class="n">donald</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Void</span><span class="o">]</span> <span class="k">=</span> <span class="nc">User</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Void</span><span class="o">](</span><span class="s">"Donald"</span><span class="o">,</span> <span class="s">"Duck"</span><span class="o">,</span> <span class="o">())</span>
</code></pre></div></div>

<p>As you can see, we cheated a bit - the goal of parameterizing our type with higher-kinded types was to ensure that we always have <code class="highlighter-rouge">String</code> (or whatever used to be in an <code class="highlighter-rouge">Option</code>) in an effect (like <code class="highlighter-rouge">Option</code> or <code class="highlighter-rouge">Id</code>), but if the effect is <code class="highlighter-rouge">A =&gt; Unit</code>, we have no <code class="highlighter-rouge">String</code> in the result whatsoever. Is it bad?</p>

<p>Maybe, maybe not.</p>

<p>If we have type parameters for our data, we can’t make it obligatory to have <code class="highlighter-rouge">String</code> anywhere in the type of <code class="highlighter-rouge">Email</code>. (well, maybe we could, using some more type-level machinery and implicits, but I don’t want to go that deep into it).</p>

<p>However, we’re making it harder to use a type that doesn’t have the <code class="highlighter-rouge">String</code> in it (<code class="highlighter-rouge">Option</code> is a more obvious choice for a type parameter than, say, <code class="highlighter-rouge">λ[A =&gt; Int]</code>, which would mean that <code class="highlighter-rouge">lastName</code> is of type <code class="highlighter-rouge">Int</code>). And we still get an escape hatch that allows us to omit some fields in a <code class="highlighter-rouge">User</code> value (by saying that <code class="highlighter-rouge">lastName</code> is of type <code class="highlighter-rouge">Unit</code>).</p>

<p>Instead of a custom <code class="highlighter-rouge">Void</code> type, we could’ve used <code class="highlighter-rouge">Const</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data.Const</span>

<span class="k">val</span> <span class="n">john</span> <span class="k">=</span> <span class="nc">User</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Const</span><span class="o">[()</span>, <span class="kt">?</span><span class="o">]](</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"De Goes"</span><span class="o">,</span> <span class="nc">Const</span><span class="o">(()))</span>
<span class="n">john</span><span class="o">.</span><span class="n">email</span><span class="o">.</span><span class="n">getConst</span> <span class="c1">// equals ()
</span></code></pre></div></div>

<p>We had at least two problems with the previous solution:</p>

<ol>
  <li>the type parameters would spread out to every place in the codebase where <code class="highlighter-rouge">User</code> appears.</li>
  <li>we didn’t have type-level hints as to what type we should use.</li>
</ol>

<p>I believe the second problem is not an issue anymore (see above argument about <code class="highlighter-rouge">Unit</code>), but the first one remains: everywhere we had</p>

<p><code class="highlighter-rouge">def foo: User =&gt; A</code>, we’ll now have</p>

<p><code class="highlighter-rouge">def foo[F[_], G[_]]: User[F, G] =&gt; A</code>. What can we do to make this a little more pleasant, and to avoid spreading every single type parameter to pieces of code that don’t care about the contents of our parameterized fields?</p>

<h2 id="variance-and-higher-kinded-types"><a href="#variance-and-higher-kinded-types">Variance and higher kinded types</a></h2>

<p>Thankfully, Scala has quite powerful support for variance annotations. We can use it to our advantage: to make our type easier to work with.</p>

<p>Suppose we are writing a function that takes a user but only uses their first name - which isn’t type parameterized. Let’s recall the definition of <code class="highlighter-rouge">User</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">[</span><span class="kt">LastName</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">Email</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
  <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">lastName</span><span class="k">:</span> <span class="kt">LastName</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
  <span class="n">email</span><span class="k">:</span> <span class="kt">Email</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span>
</code></pre></div></div>

<p>Let’s add some variance annotations…</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">[</span><span class="kt">+LastName</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">+Email</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span>
  <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">lastName</span><span class="k">:</span> <span class="kt">LastName</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
  <span class="n">email</span><span class="k">:</span> <span class="kt">Email</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span>

<span class="k">object</span> <span class="nc">User</span> <span class="o">{</span>
  <span class="c1">// apparently, Any is kind-polymorphic
</span>  <span class="c1">// and counts as a suitable * -&gt; * kinded type!
</span>  <span class="k">type</span> <span class="kt">Arb</span> <span class="o">=</span> <span class="nc">User</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">Any</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Making our type covariant in both type parameters should allow us to pass a <code class="highlighter-rouge">User[F, G]</code> for any <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">G</code> where a <code class="highlighter-rouge">User[Any, Any]</code> (<code class="highlighter-rouge">User.Arb</code>) is required. Let’s see if it works:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">nameTwice</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User.Arb</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="o">++</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span>

<span class="o">&gt;</span> <span class="n">nameTwice</span><span class="o">(</span><span class="nc">User</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Id</span><span class="o">](</span><span class="s">"Mike"</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="s">"mike@evilmail.com"</span><span class="o">))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"MikeMike"</span>
</code></pre></div></div>

<p>Looks like it does. However, maybe hardcoding <code class="highlighter-rouge">Any, Any</code> isn’t the best solution there - what if at some point we actually want to perform some validation and use the parameterized fields? Maybe a better encoding would be this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//class User defined as above
</span>
<span class="k">object</span> <span class="nc">User</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Canonical</span> <span class="o">=</span> <span class="nc">User</span><span class="o">[</span><span class="kt">Option</span>, <span class="kt">Option</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we could write functions taking <code class="highlighter-rouge">User.Canonical</code> as the base case, and only customize the functions that we want to work with certain types of <code class="highlighter-rouge">User</code> specifically.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">worksWithAllUsers</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User.Canonical</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">lastName</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">lastName</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="n">email</span><span class="o">))</span> <span class="k">=&gt;</span>
      <span class="n">withFullUser</span><span class="o">(</span>
        <span class="n">user</span><span class="o">.</span><span class="n">copy</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Id</span><span class="o">](</span>
          <span class="n">lastName</span> <span class="k">=</span> <span class="n">lastName</span><span class="o">,</span>
          <span class="n">email</span> <span class="k">=</span> <span class="n">email</span>
        <span class="o">)</span>
      <span class="o">)</span>

    <span class="k">case</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">lastName</span><span class="o">),</span> <span class="nc">None</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">withPartialUser</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">copy</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Option</span><span class="o">](</span><span class="n">lastName</span> <span class="k">=</span> <span class="n">lastName</span><span class="o">))</span>

    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="o">(</span><span class="s">"Default"</span><span class="o">,</span> <span class="s">"default@evilmail.com"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">withFullUser</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Id</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">lastName</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="o">)</span>

<span class="k">def</span> <span class="n">withPartialUser</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Any</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">lastName</span><span class="o">,</span> <span class="s">"default@evilmail.com"</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="other-possible-use-cases"><a href="#other-possible-use-cases">Other possible use cases</a></h2>

<p>What other invariants can we encode?</p>

<ul>
  <li><code class="highlighter-rouge">Option[A]</code> can become <code class="highlighter-rouge">A</code> or <code class="highlighter-rouge">Unit</code>.</li>
  <li><code class="highlighter-rouge">Either[A, B]</code> can become <code class="highlighter-rouge">B</code> or <code class="highlighter-rouge">A</code>.</li>
  <li><code class="highlighter-rouge">List[A]</code> can become <code class="highlighter-rouge">Unit</code> (empty list) or <code class="highlighter-rouge">(A, List[A])</code> (<code class="highlighter-rouge">NonEmptyList[A]</code>).</li>
</ul>

<p>(note how we’re deconstructing the data types, which happen to be ADTs, into coproducts)</p>

<p>If we’re really trying to experiment, we can go the extra mile:</p>

<ul>
  <li><code class="highlighter-rouge">List[A]</code> can be checked for length and encoded as <code class="highlighter-rouge">Sized[List[A], 5]</code>.</li>
  <li><code class="highlighter-rouge">User[IO[A]]</code> can become <code class="highlighter-rouge">IO[User[A]]</code> (sounds like <a href="https://typelevel.org/cats/typeclasses/traverse.html"><code class="highlighter-rouge">Traverse</code></a>, doesn’t it?) - we can run the IO outside and keep the result to avoid unnecessary recalculation.</li>
  <li><code class="highlighter-rouge">User[Stream[IO, A]]</code> can become <code class="highlighter-rouge">IO[User[List[A]]]</code> - we can run the stream and work with it as a list, once it’s all consumed (that is, if it fits into the memory).</li>
</ul>

<p>There’s a lot we can do, really:</p>

<ul>
  <li><code class="highlighter-rouge">String</code> -&gt; <code class="highlighter-rouge">NonEmptyString</code>, <code class="highlighter-rouge">regex"(a-Z)+"</code>, <code class="highlighter-rouge">IPv4</code>, <code class="highlighter-rouge">INetAddress</code> refined types</li>
  <li><code class="highlighter-rouge">Int</code> -&gt; <code class="highlighter-rouge">PosInt</code> / <code class="highlighter-rouge">EvenInt</code> refined types, smaller primitives (<code class="highlighter-rouge">Byte</code>, etc.)</li>
</ul>

<h2 id="summary"><a href="#summary">Summary</a></h2>

<p>There are a few good reasons for trying to make our data coherent, including but not limited to using the techniques mentioned in this post:</p>

<ul>
  <li>additional type safety by enforcing constraints locally on the type level</li>
  <li>increased ease of putting code under test - if your function doesn’t depend on <code class="highlighter-rouge">lastName</code>, you can pass <code class="highlighter-rouge">()</code> in that field safely</li>
</ul>

<p>However, there are difficulties associated with all that:</p>

<ul>
  <li>type parameters creeping into all your functions (possibly can be avoided by introducing a canonical type and only being specific when it’s needed)</li>
  <li>it’s questionable whether parameterizing data with types scales (e.g. if we have <code class="highlighter-rouge">case class Users[Collection[_], LastName[_]](users: Collection[User[LastName]])</code>, is it going to be easy to change?)</li>
  <li>the benefit might not be that significant after all</li>
  <li>it was mentioned in <a href="https://twitter.com/fanf42/status/1117684098364055552">the replies</a> that type-parameterizing e.g. JSON models can break tooling like circe, magnolia, etc. - most likely because they don’t support <a href="https://en.wikibooks.org/wiki/Haskell/GADT">GADTs</a></li>
  <li>possibly more problems that I haven’t figured out yet.</li>
</ul>

<p>I haven’t seen this approach to abstracting on data used anywhere, so I don’t know what the best practice is, and whether the idea is feasible for use in real projects, but it certainly seems worth investigating.</p>

<p>Maybe type-parameterized data would work better with lenses (e.g. from <a href="http://julien-truffaut.github.io/Monocle">Monocle</a>) to make the work with copying more pleasant and less boilerplatey?</p>

<p>As some of our validations involved e.g. breaking up <code class="highlighter-rouge">Option</code> into a tagged coproduct of <code class="highlighter-rouge">Unit</code> and <code class="highlighter-rouge">A</code> (which it is), maybe the techniques mentioned in this post could be used together with optics like Prisms (which are meant for working with coproducts) to form more powerful abstractions?</p>

<p>Maybe we could have a <code class="highlighter-rouge">Monad</code>/<code class="highlighter-rouge">Traverse</code>/whatever instance for a type like <code class="highlighter-rouge">case class User[LastName[_], Email[_]](...)</code> for each of its fields to get additional functionality for free using the functions defined on the appropriate typeclass?</p>

<p>As you can see, more insight into the possibilities is needed to determine if the concept can be used more widely in our code.</p>

<h2 id="parting-words"><a href="#parting-words">Parting words</a></h2>

<p>Thank you for reading.</p>

<p>These ideas are very fresh for me, and I haven’t spent a lot of time researching them yet. In the future, I hope to spend more time in this area and to develop a more formal or constrained description of the ideas mentioned here.</p>

<p>Most importantly, I hope to find out whether these ideas actually help achieve more type safety without sacrificing maintainability in real world programming.</p>

<p>Let me know what you think about the ideas presented in this post, and whether you enjoyed reading it!</p>

<p>Thanks to <a href="https://twitter.com/hmemcpy">Igal Tabachnik (@hmemcpy)</a> and <a href="https://twitter.com/etaty">Valérian (@etaty)</a> who found and reported a few bugs in this post. I should get around to using <a href="https://github.com/scalameta/mdoc">mdoc</a> already…</p>

	  ]]></description>
	</item>

	<item>
	  <title>What makes a function pure?</title>
	  <link>//what-makes-a-function-pure</link>
	  <author></author>
	  <pubDate>2018-12-02T12:00:00+00:00</pubDate>
	  <guid>//what-makes-a-function-pure</guid>
	  <description><![CDATA[
	     <p>Everyone knows that naming things is hard. In fact, often it seems to be one of the hardest things
in computer science and programming in general. In addition, sometimes a single word has multiple meanings,
or worse - a term is explained in a variety of slightly differing definitions. One such term is a pure function.</p>

<p>I’m by no means an expert in functional programming, but the definition of a pure function that I consider to be true
is the same one as plenty of people use.</p>

<p>That definition doesn’t distinguish pure and impure functions, though - all functions are
pure, but the impure things we sometimes call functions, aren’t. They are impure, and I call them procedures.</p>

<p>What makes a function a function, then?</p>

<p>The point of this post is to answer that question in a way that’ll be relatively easy
to understand for people with basic to intermediate experience with programming and Scala.</p>

<p>The definition for a function (and for functional programming) I use is very similar
to the one <a href="https://twitter.com/jdegoes/status/936301872066977792" target="_blank">John A de Goes tweeted some time ago</a>. Functions are:</p>

<ol>
  <li>Total - they are defined for every input</li>
  <li>Deterministic - a function will always return the same value given the same input.</li>
  <li>Pure - their only effect is computing their output</li>
</ol>

<p>If we define functions like the above, then functional programming is
programming with functions,without procedures.</p>

<p>Let’s look at these properties and see how they differ from those of what I defined as procedures.</p>

<h2 id="totality"><a href="#totality">Totality</a></h2>

<p>For a function to be total, we must make sure that it returns a value
for every kind of input that the compiler allows it to take.
That means it can’t throw exceptions to the caller, like in the following example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">trimmed</span> <span class="k">=</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">trim</span>
  <span class="k">if</span><span class="o">(</span><span class="n">trimmed</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Name is empty!"</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">trimmed</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The above code compiles, and <code class="highlighter-rouge">validate("")</code> will compile too (as a method call
with a result type of <code class="highlighter-rouge">String</code>), but it’ll crash at runtime, unless the exception is caught.
That makes <code class="highlighter-rouge">validate</code> a partial function, because it doesn’t have a
defined value of its declared type (<code class="highlighter-rouge">String</code>) for an empty string - in fact,
it doesn’t have one for any kind of input consisting exclusively of whitespace.</p>

<p>One functional alternative to this would be to use <code class="highlighter-rouge">Option</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">trim</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="s">""</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="n">trimmed</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">trimmed</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Or, if you want more information about the origin of failure, <code class="highlighter-rouge">Either</code> (if you
like typed errors, that’d probably involve creating an ADT for possible errors):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">UserError</span> <span class="k">extends</span> <span class="nc">Product</span> <span class="k">with</span> <span class="nc">Serializable</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">NameIsEmpty</span> <span class="k">extends</span> <span class="nc">UserError</span>

<span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">UserError</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> 
  <span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">trim</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">""</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="nc">NameIsEmpty</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">trimmed</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">trimmed</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Another solution would involve tagless style with <code class="highlighter-rouge">ApplicativeError</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">UserErrors</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">ApplicativeError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">UserError</span><span class="o">]</span>

<span class="k">def</span> <span class="n">validate</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">UserErrors</span><span class="o">](</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">trim</span>
    <span class="o">.</span><span class="n">some</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span>
    <span class="o">.</span><span class="n">liftTo</span><span class="o">[</span><span class="kt">F</span><span class="o">](</span><span class="nc">NameIsEmpty</span><span class="k">:</span> <span class="kt">UserError</span><span class="o">)</span>
<span class="o">}</span>
  
<span class="k">type</span> <span class="kt">E</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]</span>
<span class="n">validate</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="nc">User</span><span class="o">(</span><span class="s">"foo"</span><span class="o">))</span>
</code></pre></div></div>

<p>By moving from throwing exceptions, we gain in at least a few ways:</p>

<ul>
  <li>it becomes more explicit for the callers what kind of errors they can observe in case of failure</li>
  <li>the types will tell us whether a function actually can fail or not</li>
  <li>we avoid the overhead of creating an exception</li>
</ul>

<p>and our function becomes total, because invalid inputs will give us a value (e.g. a <code class="highlighter-rouge">Left</code>)</p>

<h2 id="determinism"><a href="#determinism">Determinism</a></h2>

<p>In order for a function to be deterministic, it has to return the same value
every time it’s called with the same arguments. Because of that, something like the following is not pure:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The type of <code class="highlighter-rouge">foo</code> is <code class="highlighter-rouge">() =&gt; Int</code>, or <code class="highlighter-rouge">Unit =&gt; Int</code>, so we can basically say that
it has one possible input (the value <code class="highlighter-rouge">()</code> of type <code class="highlighter-rouge">Unit</code>, in this case represented
by “no arguments passed”). This would mean that every call to this function will
return the same value, but it’s quite the opposite - it’ll usually return completely different values.</p>

<p>A simple way to ensure determinism of the above would be to allow passing
a seed to the randomizer, instead of using a global Random instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">seed</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="n">seed</span><span class="o">).</span><span class="n">nextInt</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, calling <code class="highlighter-rouge">foo</code> with the same input will yield the same outputs.</p>

<p>Another example of a nondeterministic function can be a simple call to a database:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//let's pretend I'm using Slick
</span><span class="k">def</span> <span class="n">findAllUsers</span><span class="o">()</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="n">db</span><span class="o">.</span><span class="n">run</span> <span class="o">{</span>
    <span class="nc">TableQuery</span><span class="o">[</span><span class="kt">Users</span><span class="o">].</span><span class="n">to</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="n">result</span>
  <span class="o">}</span>
  
  <span class="c1">//please don't do this in real code
</span>  <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">Await</code> call was added only to make sure that we have a result immediately when the function completes.</p>

<p>If we change the state of the database between a few calls to this function,
it’ll yield different results. A functional, yet implausible solution would be to
pass the state of the database as input to the function, or use some sort of <code class="highlighter-rouge">State</code> monad.
An alternative, arguably better solution would be to suspend
the side effect (reading from external mutable state) in an effect,
which is what we’ll discuss in <a href="#first-class-effects">the part of this post about First-class effects</a>.</p>

<h2 id="purity"><a href="#purity">Purity</a></h2>

<p>I already said that a function is pure because its only effect is computing its output.
Does it mean that by programming with functions we aren’t allowed to write to a database or to standard output?</p>

<p>Not at all! Writing functions that execute I/O operations, or any other kind of effects,
is possible, and it’s way easier than naming things, in fact. However, it doesn’t mean
we’re allowed to have functions with side effects.</p>

<p>What does it mean to have side effects, and how do we get effects (like talking to
external systems) without side effects? We need referential transparency.
And side effects are its exact opposite.</p>

<h2 id="referential-transparency"><a href="#referential-transparency">Referential transparency</a></h2>

<p>A definition of referential transparency found in
<a href="https://www.manning.com/books/functional-programming-in-scala">The red book (Functional Programming in Scala by Runar Bjarnason and Paul Chiusano)</a>
says:</p>

<blockquote>
  <p>An expression e is referentially transparent if, for all programs p,
all occurrences of e in p can be replaced by the result of evaluating e
without affecting the meaning of p.
A function f is pure if the expression f(x) is referentially transparent
for all referentially transparent x.</p>
</blockquote>

<p>Let me follow up with an example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="n">e</span> <span class="o">+</span> <span class="n">e</span>
</code></pre></div></div>

<p>Our <code class="highlighter-rouge">e</code> is <code class="highlighter-rouge">a + 1</code>. Our program <code class="highlighter-rouge">p</code> has two appearances of <code class="highlighter-rouge">e</code>.</p>

<p>In its current shape, the value of <code class="highlighter-rouge">p</code> can be computed by calculating <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">e</code> and <code class="highlighter-rouge">p</code> in that order:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 2 + 1 = 3
e = a + 1 = 3 + 1 = 4

p = e + e = 4 + 4 = 8
</code></pre></div></div>

<p>If we can apply the replacement of <code class="highlighter-rouge">e</code> in the original program with
the result of evaluating <code class="highlighter-rouge">e</code> (<code class="highlighter-rouge">a + 1</code>), then <code class="highlighter-rouge">e</code> is referentially transparent. Let’s do that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>What’s the value of <code class="highlighter-rouge">p</code> now?</p>

<p><code class="highlighter-rouge">p = ((2 + 1) + 1) + (2 + 1) + 1) = (3 + 1) + (3 + 1) = 4 + 4 = 8</code></p>

<p>As you see, the value of <code class="highlighter-rouge">p</code> hasn’t changed. The behavior of
the program <code class="highlighter-rouge">p</code> didn’t change either, as its only effect was computing the value (which is <code class="highlighter-rouge">8</code>). That means <code class="highlighter-rouge">e</code> was referentially transparent - we replaced the reference to a value (<code class="highlighter-rouge">e</code>) with the value (<code class="highlighter-rouge">a + 1</code>).</p>

<p>This is very much like math from school - you didn’t see
anything impure in your textbooks, all your expressions were pure,
and you could apply substitution in a similar way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(x) = x + 1

g(x) = f(x + 1) + f(x)
g(x) = ((x + 1) + 1) + (x + 1) = 2x + 3
</code></pre></div></div>

<p>So far, no side effects. Let’s introduce some:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">)</span>
  <span class="mi">1</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</code></pre></div></div>

<p>If we ran the above lines in a REPL session, or as part of a larger program, the effects would be:</p>

<ul>
  <li>the value of <code class="highlighter-rouge">p</code> becomes <code class="highlighter-rouge">2</code> (every time)</li>
  <li>the line <code class="highlighter-rouge">Foo</code> is printed to console output once.</li>
</ul>

<p>What would happen if we inlined <code class="highlighter-rouge">x</code> into the places where it’s used?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">)</span>
  <span class="mi">1</span>
<span class="o">}</span> <span class="o">+</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">)</span>
  <span class="mi">1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, if we ran the above lines, the result would be vastly different from the previous one, perhaps unsurprisingly:</p>

<ul>
  <li>the value of <code class="highlighter-rouge">p</code> still becomes <code class="highlighter-rouge">2</code> (every time)</li>
  <li>the line <code class="highlighter-rouge">Foo</code> is printed to console output <strong>twice</strong>.</li>
</ul>

<p>Unless all the effects of your programs are idempotent
(running them multiple times yields the same result as running them once),
which I doubt, then this should feel troubling: after all,
the only thing we did was inline a read-only variable (<code class="highlighter-rouge">val x</code>).
And now the program behaves in a different way.</p>

<p>That’s precisely because the implementation of <code class="highlighter-rouge">x</code> was impure - it had
a secondary effect (or a side effect) of console output. This could just as well be
a database-mutating call, or a <code class="highlighter-rouge">HTTP POST</code> request being sent to a remote server.
In many cases, it would become a bug.</p>

<p>There are other ways to break referential transparency.
If the value of <code class="highlighter-rouge">x</code> depended on external conditions (like if it was getting its value from console input),
the correctness of the program after inlining could break in many more ways:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>

<span class="k">val</span> <span class="n">prog1</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="k">val</span> <span class="n">prog2</span> <span class="k">=</span> <span class="o">(</span><span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">(),</span> <span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">())</span>

<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">prog1</span> <span class="o">==</span> <span class="n">prog2</span>
</code></pre></div></div>

<p>In the above code, the tuple contained by <code class="highlighter-rouge">prog1</code> will always have
the same value in both fields. In fact, if we only ran the code up to the definition of <code class="highlighter-rouge">prog1</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span>

<span class="k">val</span> <span class="n">prog1</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>We would be asked to enter console input once, and the value we typed
would be stored in <code class="highlighter-rouge">x</code> for as long as <code class="highlighter-rouge">x</code>’s lifetime lasts. Because of that, it’d appear twice in <code class="highlighter-rouge">prog1</code>.</p>

<p>However, if we only ran the line where <code class="highlighter-rouge">prog2</code> is defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">prog2</span> <span class="k">=</span> <span class="o">(</span><span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">(),</span> <span class="nc">StdIn</span><span class="o">.</span><span class="n">readLine</span><span class="o">())</span>
</code></pre></div></div>

<p>We would be asked for input <strong>twice</strong>, and assuming there are <code class="highlighter-rouge">n</code> possible strings
we could input, the chance that both values in <code class="highlighter-rouge">prog2</code> would be the same
would be equal to only <code class="highlighter-rouge">1/n</code> (as opposed to <code class="highlighter-rouge">100%</code> in <code class="highlighter-rouge">prog1</code>). And the only difference
between <code class="highlighter-rouge">prog1</code> and <code class="highlighter-rouge">prog2</code> was the inlining of <code class="highlighter-rouge">x = StdIn.readLine()</code>.</p>

<p>There are many other ways to break referential transparency in Scala, for example throwing exceptions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">prog1</span> <span class="k">=</span> <span class="nc">Try</span><span class="o">(</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span>

<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span>
<span class="k">val</span> <span class="n">prog2</span> <span class="k">=</span> <span class="nc">Try</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</code></pre></div></div>

<p>or executing any kind of impure logic inside <code class="highlighter-rouge">scala.concurrent.Future</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">)</span> <span class="o">}</span>

<span class="k">val</span> <span class="n">prog1</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="n">zip</span> <span class="n">x</span><span class="o">)</span>
<span class="k">val</span> <span class="n">prog2</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Future</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">)</span> <span class="o">}</span> <span class="n">zip</span> <span class="nc">Future</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">)</span> <span class="o">})</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Future</code> behaves just like a raw, uncut side effect: its value is cached, so regardless of how many times you use
an already created <code class="highlighter-rouge">Future</code>, it’ll only run once and it’ll always contain the same value upon completion or failure.
That’s because <code class="highlighter-rouge">Future</code> isn’t a description of an asynchronous computation: it’s already running one.</p>

<p>If we can’t rely on <code class="highlighter-rouge">Future</code> to give us the safety of refactoring (inlining values or extracting expressions to values),
does it mean we’re doomed to have side effects in meaningful Scala programs?</p>

<p>Thankfully, it doesn’t.</p>

<h2 id="first-class-effects"><a href="#first-class-effects">First-class effects</a></h2>

<p>A term often used to describe effects without side effects is “first class effects”. They are effects that don’t break
referential transparency. A workaround often used to simulate support for first class effects in Scala
involves by-name parameters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//artificial type
</span><span class="k">final</span> <span class="k">class</span> <span class="nc">Effectful</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">private</span><span class="o">(</span><span class="n">run</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">Effectful</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Effectful</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Effectful</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">run</span><span class="o">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">run</span><span class="o">()))</span>
<span class="o">}</span>

<span class="c1">//function with by-name parameter
</span><span class="k">def</span> <span class="n">effect</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Effectful</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Effectful</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">)</span>

<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">effect</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">))</span>

<span class="k">val</span> <span class="n">prog1</span> <span class="k">=</span> <span class="n">x</span> <span class="n">zip</span> <span class="n">x</span>

<span class="k">val</span> <span class="n">prog2</span> <span class="k">=</span> <span class="n">effect</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">))</span> <span class="n">zip</span> <span class="n">effect</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">))</span>
</code></pre></div></div>

<p>In this example, we created a new, “artificial” type <code class="highlighter-rouge">Effectful[T]</code> (it’s probably not a good idea to try
and come up with a type like this on your own). It describes a computation that will complete with a value of type <code class="highlighter-rouge">T</code>.
We gave it a method <code class="highlighter-rouge">zip</code> that will produce a new <code class="highlighter-rouge">Effectful</code> that will run two <code class="highlighter-rouge">Effectful</code> programs sequentially.</p>

<p>If we were to call <code class="highlighter-rouge">prog1.run()</code> or <code class="highlighter-rouge">prog2.run()</code>, you’d see that they behave identically - they’ll both print <code class="highlighter-rouge">Foo</code> twice.</p>

<p>Thankfully, we don’t need to come up with a type like this (and I don’t recommend that you do - unless
you’re absolutely sure the existing ones don’t meet your needs).</p>

<p>There’s plenty of competing options one can use in a similar way to how we used <code class="highlighter-rouge">Effectful</code> and <code class="highlighter-rouge">def effect</code>. 
Here are a few that are the most popular in late 2018:</p>

<ul>
  <li>cats-effect <code class="highlighter-rouge">IO[+A]</code></li>
  <li>scalaz-zio <code class="highlighter-rouge">IO[+E, +A]</code></li>
  <li>Monix <code class="highlighter-rouge">Task[+A]</code>.</li>
</ul>

<p>From the referential transparency/purity point of view, they behave in the same way - if we “suspend” side-effecting
operations using an operator that allows “delaying” a computation (for example, by taking a by-name parameter),
they’ll give us the properties we need. One significant difference in the above is in terms of
error handling - <code class="highlighter-rouge">zio</code> allows an <code class="highlighter-rouge">IO</code> to fail with an error value of type <code class="highlighter-rouge">E</code> that you can specify on your own,
but the other two (cats-effect IO and Monix Task) only allow failure with values that extend <code class="highlighter-rouge">Throwable</code>.
Whether one solution has significant advantages over the other is a question for a different post ;)</p>

<p>All things considered, all of the above types support suspending synchronous effects (like printing to standard output,
or executing a JDBC call) and asynchronous, non-blocking effects (like communicating through HTTP or
listening for messages from Kafka). The main difference between these types and <code class="highlighter-rouge">Future</code> is that they are able to
<em>describe a computation</em> that can be ran at some point after they’re defined, while <code class="highlighter-rouge">Future</code> is
a handle to an already running computation.</p>

<p>For the next part of the post, I’ll use cats-effect’s <code class="highlighter-rouge">IO</code>.</p>

<p>Let’s recreate the printing example that we were able to make referentially transparent with <code class="highlighter-rouge">Effectful</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.syntax.apply._</span>
<span class="k">import</span> <span class="nn">cats.effect.IO</span>

<span class="cm">/*
 * expands to `IO.apply(println(...))`,
 * defined as `def apply[T](f: =&gt; T): IO[T]`
 * `IO.apply` is equivalent to `IO.delay`
 */</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">))</span>

<span class="k">val</span> <span class="n">prog1</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">).</span><span class="n">tupled</span>

<span class="k">val</span> <span class="n">prog2</span> <span class="k">=</span> <span class="o">(</span><span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">)),</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">))).</span><span class="n">tupled</span>
</code></pre></div></div>

<p>Again, running <code class="highlighter-rouge">prog1</code> and/or <code class="highlighter-rouge">prog2</code> will involve printing twice in each of them. That’s why
we say IO is referentially transparent, or pure.</p>

<h2 id="a-word-on-determinism-and-io"><a href="#a-word-on-determinism-and-io">A word on determinism and IO</a></h2>

<p>Earlier, I claimed that a function needs to return the same output for the same input. Would this be a function, then?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
  <span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Some people would argue that it’s not - because it’s not deterministic. They argue that calling <code class="highlighter-rouge">foo</code> multiple times
will give you different results. But that’s not true - just calling <code class="highlighter-rouge">foo</code> always gives you
the same action - nothing happens until you evaluate the IO. In fact, the whole function could be a constant:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">foo</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span> <span class="nc">Random</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span> <span class="o">}</span>
</code></pre></div></div>

<p>And as a constant it must be deterministic. The fact that evaluating it multiple times will give us different
results doesn’t matter. One of the points of functions being deterministic is to allow storing them as values,
and reusing them. Take a look:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="k">val</span> <span class="n">program</span> <span class="k">=</span> <span class="n">foo</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span> <span class="o">*&gt;</span> <span class="n">bar</span> <span class="o">&lt;*</span> <span class="n">foo</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="k">val</span> <span class="n">program2</span> <span class="k">=</span> <span class="n">baz</span> <span class="o">&lt;*</span> <span class="n">foo</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>Because all the calls to <code class="highlighter-rouge">foo</code> are the same, we can store the result of such a call and reuse it, while maintaining
the original behavior:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>

<span class="k">val</span> <span class="n">foo5</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">foo</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="k">val</span> <span class="n">program</span> <span class="k">=</span> <span class="n">foo5</span> <span class="o">*&gt;</span> <span class="n">bar</span> <span class="o">&lt;*</span> <span class="n">foo5</span>

<span class="k">val</span> <span class="n">program2</span> <span class="k">=</span> <span class="n">baz</span> <span class="o">&lt;*</span> <span class="n">foo5</span>
</code></pre></div></div>

<p>“How do we evaluate an IO?”, you may ask. I’ll respond, “with <code class="highlighter-rouge">IOApp</code>” (for example):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.effect._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">IOApp</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">ExitCode</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">foo</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"Foo"</span><span class="o">))</span>
    
    <span class="n">foo</span> <span class="o">*&gt;</span> <span class="n">foo</span> <span class="o">*&gt;</span> <span class="n">foo</span>
  <span class="o">}.</span><span class="n">as</span><span class="o">(</span><span class="nc">ExitCode</span><span class="o">.</span><span class="nc">Success</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="thanks-for-reading"><a href="#thanks-for-reading">Thanks for reading</a></h2>

<p>I hope that you liked this not-so-short explanation of pure functions and that you’ll benefit from it as much as me
and other people who believe in functional programming. If you still have any questions,
feel free to reach out to me in the comments or through my Twitter/email :)</p>

<p>If you think this post helped you, please share it on Twitter/Reddit/whatever you like. And while you’re at it,
please leave a comment ;)</p>

<p>If you want to keep an eye out for the next thing I write, follow me and I’ll make sure
you don’t miss anything readworthy.</p>

<h2 id="links"><a href="#links">Links</a></h2>

<p>To learn more about referential transparency, first-class effects and IO,
check out <a href="https://typelevel.org/cats-effect/datatypes/io.html" target="_blank">the documentation of cats.effect.IO</a>,
or <a href="https://www.reddit.com/r/scala/comments/8ygjcq/can_someone_explain_to_me_the_benefits_of_io/e2jfp9b" target="_blank">Fabio Labella’s comments in this Reddit thread</a>.
You may also want to see <a href="https://www.youtube.com/watch?v=X-cEGEJMx_4" target="_blank">Luka Jacobowitz’s talk about the other benefits of RT</a>,
<a href="https://www.youtube.com/watch?v=po3wmq4S15A" target="_blank">Rob Norris’s introduction to Effects</a>
and <a href="https://vimeo.com/294736344" target="_blank">Fabio’s talk about shared mutable state in pure FP</a>.</p>

<p>If you don’t mind seeing a bunch of slides without an audible explanation,
you can also check out <a href="https://kubukoz.github.io/talks/incremental-purity/slides" target="_blank">the slides for my latest talk</a>,
but sooner or later I’m planning to have it recorded and the video published.</p>

<p>For examples with ZIO, see <a href="https://scalaz.github.io/scalaz-zio/usage/purity.html" target="_blank">ZIO’s page on purity</a>.</p>

<p>I also recommend following <a href="https://typelevel.org/blog/" target="_blank">the Typelevel blog</a> and
chatting to folks who love FP on <a href="https://gitter.im/typelevel/cats" target="_blank">the cats gitter</a> and
<a href="https://gitter.im/typelevel/cats-effect">other</a> related <a href="https://gitter.im/typelevel/general" target="_blank">rooms</a>.</p>

	  ]]></description>
	</item>


</channel>
</rss>
