<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>What makes a function pure?</title>
    <meta name="description" content="Everyone knows that naming things is hard. In fact, often it seems to be one of the hardest things
in computer science and programming in general. In addition, sometimes a single word has multiple meanings,
or worse - a term is explained in a variety of slightly differing definitions. One such term is a pure function.">

    <link rel="stylesheet" href="https://blog.kubukoz.com/main.css">
    <link rel="stylesheet" href="https://blog.kubukoz.com/custom.css">
    <link rel="icon" type="image/x-icon" href="/images/favicon.svg">

    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="https://blog.kubukoz.com/atom.xml">
    

    
    
</head>
<body>
    
    <div class="cover-image" style="background-image: url(&#x2F;images&#x2F;pure-function-bg.jpg)"></div>
    
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header>
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;blog.kubukoz.com">Jakub Koz≈Çowski</a> | A 1.00000000000001x engineering blog
            </h1>
            <nav>
                
                
                
                <a  href="https:&#x2F;&#x2F;blog.kubukoz.com&#x2F;talks&#x2F;">Talks</a>
                
                
            </nav>
        </header>
        <div class="search-container">
            <input id="searchbox" type="search" placeholder="Search">
            <div class="search-results">
                <div class="search-results__items">
                </div>
            </div>
        </div>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>What makes a function pure?</h1>
    </header>
    <div class="content">
        <p>Everyone knows that naming things is hard. In fact, often it seems to be one of the hardest things
in computer science and programming in general. In addition, sometimes a single word has multiple meanings,
or worse - a term is explained in a variety of slightly differing definitions. One such term is a pure function.</p>
<span id="continue-reading"></span>
<p>I'm by no means an expert in functional programming, but the definition of a pure function that I consider to be true
is the same one as plenty of people use.</p>
<p>That definition doesn't distinguish pure and impure functions, though - all functions are
pure, but the impure things we sometimes call functions, aren't. They are impure, and I call them procedures.</p>
<p>What makes a function a function, then?</p>
<p>The point of this post is to answer that question in a way that'll be relatively easy
to understand for people with basic to intermediate experience with programming and Scala.</p>
<p>The definition for a function (and for functional programming) I use is very similar
to the one <a rel="noopener" target="_blank" href="https://twitter.com/jdegoes/status/936301872066977792">John A de Goes tweeted some time ago</a>. Functions are:</p>
<ol>
<li>Total - they are defined for every input</li>
<li>Deterministic - a function will always return the same value given the same input.</li>
<li>Pure - their only effect is computing their output</li>
</ol>
<p>If we define functions like the above, then functional programming is
programming with functions,without procedures.</p>
<p>Let's look at these properties and see how they differ from those of what I defined as procedures.</p>
<h2 id="totality"><a class="zola-anchor" href="#totality" aria-label="Anchor link for: totality">Totality</a></h2>
<p>For a function to be total, we must make sure that it returns a value
for every kind of input that the compiler allows it to take.
That means it can't throw exceptions to the caller, like in the following example:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">validate</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">user</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">User</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">String</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">trimmed</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> user<span class="z-punctuation z-accessor z-scala">.</span>name<span class="z-punctuation z-accessor z-scala">.</span>trim
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-keyword z-control z-flow z-scala">if</span><span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>trimmed<span class="z-punctuation z-accessor z-scala">.</span>isEmpty<span class="z-punctuation z-section z-group z-end z-scala">)</span></span> <span class="z-keyword z-control z-flow z-jump z-scala">throw</span> <span class="z-keyword z-other z-scala">new</span> <span class="z-support z-class z-scala">Exception</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Name is empty!<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-keyword z-control z-flow z-scala">else</span> trimmed
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>The above code compiles, and <code>validate(&quot;&quot;)</code> will compile too (as a method call
with a result type of <code>String</code>), but it'll crash at runtime, unless the exception is caught.
That makes <code>validate</code> a partial function, because it doesn't have a
defined value of its declared type (<code>String</code>) for an empty string - in fact,
it doesn't have one for any kind of input consisting exclusively of whitespace.</p>
<p>One functional alternative to this would be to use <code>Option</code>:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">validate</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">user</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">User</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">Option</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">String</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> user<span class="z-punctuation z-accessor z-scala">.</span>name<span class="z-punctuation z-accessor z-scala">.</span>trim <span class="z-keyword z-control z-flow z-scala">match</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-keyword z-other z-declaration z-scala">case</span><span class="z-meta z-pattern z-scala"> <span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span><span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span> </span><span class="z-storage z-type z-function z-arrow z-case z-scala">=&gt;</span><span class="z-meta z-block z-case z-first z-scala"> <span class="z-support z-constant z-scala">None</span>
</span></span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-meta z-block z-case z-first z-scala">  </span><span class="z-keyword z-other z-declaration z-scala">case</span><span class="z-meta z-pattern z-scala"> <span class="z-variable z-parameter z-scala">trimmed</span> </span><span class="z-storage z-type z-function z-arrow z-case z-scala">=&gt;</span><span class="z-meta z-block z-case z-non-first z-scala"> <span class="z-support z-constant z-scala">Some</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>trimmed<span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-meta z-block z-case z-non-first z-scala"></span><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>Or, if you want more information about the origin of failure, <code>Either</code> (if you
like typed errors, that'd probably involve creating an ADT for possible errors):</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-modifier z-other z-scala">sealed</span> <span class="z-meta z-class z-identifier z-scala"><span class="z-storage z-type z-class z-scala">trait</span><span class="z-entity z-name z-class z-scala"> UserError</span></span> <span class="z-keyword z-declaration z-scala">extends</span> <span class="z-entity z-other z-inherited-class z-scala">Product</span> <span class="z-keyword z-declaration z-scala">with</span> <span class="z-entity z-other z-inherited-class z-scala">Serializable</span>
</span><span class="z-source z-scala"><span class="z-meta z-class z-identifier z-scala"><span class="z-storage z-type z-class z-scala">case </span><span class="z-storage z-type z-class z-scala">object</span><span class="z-entity z-name z-class z-scala"> NameIsEmpty</span></span> <span class="z-keyword z-declaration z-scala">extends</span> <span class="z-entity z-other z-inherited-class z-scala">UserError</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">validate</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">user</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">User</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">Either</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">UserError</span><span class="z-punctuation z-separator z-scala">,</span> <span class="z-support z-class z-scala">String</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span>
</span><span class="z-source z-scala">  user<span class="z-punctuation z-accessor z-scala">.</span>name<span class="z-punctuation z-accessor z-scala">.</span>trim <span class="z-keyword z-control z-flow z-scala">match</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">    <span class="z-keyword z-other z-declaration z-scala">case</span><span class="z-meta z-pattern z-scala"> <span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span><span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span> </span><span class="z-storage z-type z-function z-arrow z-case z-scala">=&gt;</span><span class="z-meta z-block z-case z-first z-scala"> <span class="z-support z-constant z-scala">Left</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">NameIsEmpty</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-meta z-block z-case z-first z-scala">    </span><span class="z-keyword z-other z-declaration z-scala">case</span><span class="z-meta z-pattern z-scala"> <span class="z-variable z-parameter z-scala">trimmed</span> </span><span class="z-storage z-type z-function z-arrow z-case z-scala">=&gt;</span><span class="z-meta z-block z-case z-non-first z-scala"> <span class="z-support z-constant z-scala">Right</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>trimmed<span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-meta z-block z-case z-non-first z-scala">  </span><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>Another solution would involve tagless style with <code>ApplicativeError</code>:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-scala">type</span> <span class="z-entity z-name z-type z-scala">UserErrors</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">F</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-variable z-language z-underscore z-scala">_</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span> <span class="z-keyword z-operator z-assignment z-scala">= </span><span class="z-support z-class z-scala">ApplicativeError</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">F</span><span class="z-punctuation z-separator z-scala">,</span> <span class="z-support z-class z-scala">UserError</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">validate</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">F</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-variable z-language z-underscore z-scala">_</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-keyword z-operator z-bound z-scala">:</span> <span class="z-support z-class z-scala">UserErrors</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">user</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">User</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">F</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">String</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  user<span class="z-punctuation z-accessor z-scala">.</span>name<span class="z-punctuation z-accessor z-scala">.</span>trim
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">    <span class="z-punctuation z-accessor z-scala">.</span>some<span class="z-punctuation z-accessor z-scala">.</span>filter<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-language z-underscore z-scala">_</span><span class="z-punctuation z-accessor z-scala">.</span>nonEmpty<span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">    <span class="z-punctuation z-accessor z-scala">.</span>liftTo<span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">F</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">NameIsEmpty</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">UserError</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-scala">type</span> <span class="z-entity z-name z-type z-scala">E</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">A</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span> <span class="z-keyword z-operator z-assignment z-scala">= </span><span class="z-support z-class z-scala">Either</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">String</span><span class="z-punctuation z-separator z-scala">,</span> <span class="z-support z-class z-scala">A</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span>
</span><span class="z-source z-scala">validate<span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">E</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">User</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></code></pre>
<p>By moving from throwing exceptions, we gain in at least a few ways:</p>
<ul>
<li>it becomes more explicit for the callers what kind of errors they can observe in case of failure</li>
<li>the types will tell us whether a function actually can fail or not</li>
<li>we avoid the overhead of creating an exception</li>
</ul>
<p>and our function becomes total, because invalid inputs will give us a value (e.g. a <code>Left</code>)</p>
<h2 id="determinism"><a class="zola-anchor" href="#determinism" aria-label="Anchor link for: determinism">Determinism</a></h2>
<p>In order for a function to be deterministic, it has to return the same value
every time it's called with the same arguments. Because of that, something like the following is not pure:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">foo</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-storage z-type z-primitive z-scala">Int</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-support z-constant z-scala">Random</span><span class="z-punctuation z-accessor z-scala">.</span>nextInt<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>The type of <code>foo</code> is <code>() =&gt; Int</code>, or <code>Unit =&gt; Int</code>, so we can basically say that
it has one possible input (the value <code>()</code> of type <code>Unit</code>, in this case represented
by &quot;no arguments passed&quot;). This would mean that every call to this function will
return the same value, but it's quite the opposite - it'll usually return completely different values.</p>
<p>A simple way to ensure determinism of the above would be to allow passing
a seed to the randomizer, instead of using a global Random instance:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">foo</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">seed</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-storage z-type z-primitive z-scala">Int</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-storage z-type z-primitive z-scala">Int</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-keyword z-other z-scala">new</span> <span class="z-support z-class z-scala">Random</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>seed<span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-accessor z-scala">.</span>nextInt<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>Now, calling <code>foo</code> with the same input will yield the same outputs.</p>
<p>Another example of a nondeterministic function can be a simple call to a database:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-comment z-line z-double-slash z-scala"><span class="z-punctuation z-definition z-comment z-scala">//</span>let&#39;s pretend I&#39;m using Slick</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">findAllUsers</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">List</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">User</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">f</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> db<span class="z-punctuation z-accessor z-scala">.</span>run <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-meta z-block z-scala">    <span class="z-support z-constant z-scala">TableQuery</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">Users</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-punctuation z-accessor z-scala">.</span>to<span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">List</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-punctuation z-accessor z-scala">.</span>result
</span></span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-meta z-block z-scala">  <span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-comment z-line z-double-slash z-scala"><span class="z-punctuation z-definition z-comment z-scala">//</span>please don&#39;t do this in real code</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-support z-constant z-scala">Await</span><span class="z-punctuation z-accessor z-scala">.</span>result<span class="z-punctuation z-section z-group z-begin z-scala">(</span>f<span class="z-punctuation z-separator z-scala">,</span> <span class="z-constant z-numeric z-integer z-decimal z-scala">5</span><span class="z-punctuation z-accessor z-scala">.</span>seconds<span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>The <code>Await</code> call was added only to make sure that we have a result immediately when the function completes.</p>
<p>If we change the state of the database between a few calls to this function,
it'll yield different results. A functional, yet implausible solution would be to
pass the state of the database as input to the function, or use some sort of <code>State</code> monad.
An alternative, arguably better solution would be to suspend
the side effect (reading from external mutable state) in an effect,
which is what we'll discuss in <a href="https://blog.kubukoz.com/what-makes-a-function-pure/#first-class-effects">the part of this post about First-class effects</a>.</p>
<h2 id="purity"><a class="zola-anchor" href="#purity" aria-label="Anchor link for: purity">Purity</a></h2>
<p>I already said that a function is pure because its only effect is computing its output.
Does it mean that by programming with functions we aren't allowed to write to a database or to standard output?</p>
<p>Not at all! Writing functions that execute I/O operations, or any other kind of effects,
is possible, and it's way easier than naming things, in fact. However, it doesn't mean
we're allowed to have functions with side effects.</p>
<p>What does it mean to have side effects, and how do we get effects (like talking to
external systems) without side effects? We need referential transparency.
And side effects are its exact opposite.</p>
<h2 id="referential-transparency"><a class="zola-anchor" href="#referential-transparency" aria-label="Anchor link for: referential-transparency">Referential transparency</a></h2>
<p>A definition of referential transparency found in
<a rel="noopener" target="_blank" href="https://www.manning.com/books/functional-programming-in-scala">The red book (Functional Programming in Scala by Runar Bjarnason and Paul Chiusano)</a>
says:</p>
<blockquote>
<p>An expression e is referentially transparent if, for all programs p,
all occurrences of e in p can be replaced by the result of evaluating e
without affecting the meaning of p.
A function f is pure if the expression f(x) is referentially transparent
for all referentially transparent x.</p>
</blockquote>
<p>Let me follow up with an example:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">a</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-constant z-numeric z-integer z-decimal z-scala">2</span> + <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">e</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> a + <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">p</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> e + e
</span></code></pre>
<p>Our <code>e</code> is <code>a + 1</code>. Our program <code>p</code> has two appearances of <code>e</code>.</p>
<p>In its current shape, the value of <code>p</code> can be computed by calculating <code>a</code>, <code>e</code> and <code>p</code> in that order:</p>
<pre class="z-code"><code><span class="z-text z-plain">a = 2 + 1 = 3
</span><span class="z-text z-plain">e = a + 1 = 3 + 1 = 4
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">p = e + e = 4 + 4 = 8
</span></code></pre>
<p>If we can apply the replacement of <code>e</code> in the original program with
the result of evaluating <code>e</code> (<code>a + 1</code>), then <code>e</code> is referentially transparent. Let's do that:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">a</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-constant z-numeric z-integer z-decimal z-scala">2</span> + <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">p</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>a + <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span><span class="z-punctuation z-section z-group z-end z-scala">)</span></span> + <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>a + <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span><span class="z-punctuation z-section z-group z-end z-scala">)</span></span>
</span></code></pre>
<p>What's the value of <code>p</code> now?</p>
<p><code>p = ((2 + 1) + 1) + (2 + 1) + 1) = (3 + 1) + (3 + 1) = 4 + 4 = 8</code></p>
<p>As you see, the value of <code>p</code> hasn't changed. The behavior of
the program <code>p</code> didn't change either, as its only effect was computing the value (which is <code>8</code>). That means <code>e</code> was referentially transparent - we replaced the reference to a value (<code>e</code>) with the value (<code>a + 1</code>).</p>
<p>This is very much like math from school - you didn't see
anything impure in your textbooks, all your expressions were pure,
and you could apply substitution in a similar way:</p>
<pre class="z-code"><code><span class="z-text z-plain">f(x) = x + 1
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">g(x) = f(x + 1) + f(x)
</span><span class="z-text z-plain">g(x) = ((x + 1) + 1) + (x + 1) = 2x + 3
</span></code></pre>
<p>So far, no side effects. Let's introduce some:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">x</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">p</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> x + x
</span></code></pre>
<p>If we ran the above lines in a REPL session, or as part of a larger program, the effects would be:</p>
<ul>
<li>the value of <code>p</code> becomes <code>2</code> (every time)</li>
<li>the line <code>Foo</code> is printed to console output once.</li>
</ul>
<p>What would happen if we inlined <code>x</code> into the places where it's used?</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">p</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span> + <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-constant z-numeric z-integer z-decimal z-scala">1</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>Now, if we ran the above lines, the result would be vastly different from the previous one, perhaps unsurprisingly:</p>
<ul>
<li>the value of <code>p</code> still becomes <code>2</code> (every time)</li>
<li>the line <code>Foo</code> is printed to console output <strong>twice</strong>.</li>
</ul>
<p>Unless all the effects of your programs are idempotent
(running them multiple times yields the same result as running them once),
which I doubt, then this should feel troubling: after all,
the only thing we did was inline a read-only variable (<code>val x</code>).
And now the program behaves in a different way.</p>
<p>That's precisely because the implementation of <code>x</code> was impure - it had
a secondary effect (or a side effect) of console output. This could just as well be
a database-mutating call, or a <code>HTTP POST</code> request being sent to a remote server.
In many cases, it would become a bug.</p>
<p>There are other ways to break referential transparency.
If the value of <code>x</code> depended on external conditions (like if it was getting its value from console input),
the correctness of the program after inlining could break in many more ways:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">x</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">StdIn</span><span class="z-punctuation z-accessor z-scala">.</span>readLine<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog1</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>x<span class="z-punctuation z-separator z-scala">,</span> x<span class="z-punctuation z-section z-group z-end z-scala">)</span></span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">StdIn</span><span class="z-punctuation z-accessor z-scala">.</span>readLine<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-separator z-scala">,</span> <span class="z-support z-constant z-scala">StdIn</span><span class="z-punctuation z-accessor z-scala">.</span>readLine<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span></span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">b</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> prog1 <span class="z-keyword z-operator z-comparison z-scala">==</span> prog2
</span></code></pre>
<p>In the above code, the tuple contained by <code>prog1</code> will always have
the same value in both fields. In fact, if we only ran the code up to the definition of <code>prog1</code>:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">x</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">StdIn</span><span class="z-punctuation z-accessor z-scala">.</span>readLine<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog1</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>x<span class="z-punctuation z-separator z-scala">,</span> x<span class="z-punctuation z-section z-group z-end z-scala">)</span></span>
</span></code></pre>
<p>We would be asked to enter console input once, and the value we typed
would be stored in <code>x</code> for as long as <code>x</code>'s lifetime lasts. Because of that, it'd appear twice in <code>prog1</code>.</p>
<p>However, if we only ran the line where <code>prog2</code> is defined:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">StdIn</span><span class="z-punctuation z-accessor z-scala">.</span>readLine<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-separator z-scala">,</span> <span class="z-support z-constant z-scala">StdIn</span><span class="z-punctuation z-accessor z-scala">.</span>readLine<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span></span>
</span></code></pre>
<p>We would be asked for input <strong>twice</strong>, and assuming there are <code>n</code> possible strings
we could input, the chance that both values in <code>prog2</code> would be the same
would be equal to only <code>1/n</code> (as opposed to <code>100%</code> in <code>prog1</code>). And the only difference
between <code>prog1</code> and <code>prog2</code> was the inlining of <code>x = StdIn.readLine()</code>.</p>
<p>There are many other ways to break referential transparency in Scala, for example throwing exceptions:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog1</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">Try</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-keyword z-control z-flow z-jump z-scala">throw</span> <span class="z-keyword z-other z-scala">new</span> <span class="z-support z-class z-scala">Exception</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">x</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-keyword z-control z-flow z-jump z-scala">throw</span> <span class="z-keyword z-other z-scala">new</span> <span class="z-support z-class z-scala">Exception</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">Try</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>x<span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></code></pre>
<p>or executing any kind of impure logic inside <code>scala.concurrent.Future</code>:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">x</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">Future</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span> println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span> <span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog1</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>x zip x<span class="z-punctuation z-section z-group z-end z-scala">)</span></span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">Future</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span> println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span> <span class="z-punctuation z-section z-block z-end z-scala">}</span></span> zip <span class="z-support z-constant z-scala">Future</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span> println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span> <span class="z-punctuation z-section z-block z-end z-scala">}</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span></span>
</span></code></pre>
<p><code>Future</code> behaves just like a raw, uncut side effect: its value is cached, so regardless of how many times you use
an already created <code>Future</code>, it'll only run once and it'll always contain the same value upon completion or failure.
That's because <code>Future</code> isn't a description of an asynchronous computation: it's already running one.</p>
<p>If we can't rely on <code>Future</code> to give us the safety of refactoring (inlining values or extracting expressions to values),
does it mean we're doomed to have side effects in meaningful Scala programs?</p>
<p>Thankfully, it doesn't.</p>
<h2 id="first-class-effects"><a class="zola-anchor" href="#first-class-effects" aria-label="Anchor link for: first-class-effects">First-class effects</a></h2>
<p>A term often used to describe effects without side effects is &quot;first class effects&quot;. They are effects that don't break
referential transparency. A workaround often used to simulate support for first class effects in Scala
involves by-name parameters:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-comment z-line z-double-slash z-scala"><span class="z-punctuation z-definition z-comment z-scala">//</span>artificial type</span>
</span><span class="z-source z-scala"><span class="z-storage z-modifier z-other z-scala">final</span> <span class="z-meta z-class z-identifier z-scala"><span class="z-storage z-type z-class z-scala">class</span><span class="z-entity z-name z-class z-scala"> Effectful</span></span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">T</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span> <span class="z-storage z-modifier z-access z-scala">private</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">run</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-punctuation z-definition z-group z-begin z-scala">(</span><span class="z-punctuation z-definition z-group z-end z-scala">)</span> <span class="z-keyword z-operator z-arrow z-scala">=&gt;</span> <span class="z-support z-class z-scala">T</span><span class="z-punctuation z-section z-group z-end z-scala">)</span> <span class="z-meta z-class z-body z-scala"><span class="z-punctuation z-section z-braces z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala">  <span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">zip</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">U</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">b</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">Effectful</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">U</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">Effectful</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-punctuation z-definition z-group z-begin z-scala">(</span><span class="z-support z-class z-scala">T</span><span class="z-punctuation z-separator z-scala">,</span> <span class="z-support z-class z-scala">U</span><span class="z-punctuation z-definition z-group z-end z-scala">)</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala">    <span class="z-keyword z-other z-scala">new</span> <span class="z-support z-class z-scala">Effectful</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span> <span class="z-storage z-type z-function z-arrow z-lambda z-scala">=&gt;</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>run<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-separator z-scala">,</span> b<span class="z-punctuation z-accessor z-scala">.</span>run<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala"><span class="z-punctuation z-section z-braces z-end z-scala">}</span></span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-comment z-line z-double-slash z-scala"><span class="z-punctuation z-definition z-comment z-scala">//</span>function with by-name parameter</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">effect</span><span class="z-meta z-generic z-scala"><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">T</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span></span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">f</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-keyword z-operator z-arrow z-scala">=&gt;</span> <span class="z-support z-class z-scala">T</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">Effectful</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">T</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-keyword z-other z-scala">new</span> <span class="z-support z-class z-scala">Effectful</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span> <span class="z-storage z-type z-function z-arrow z-lambda z-scala">=&gt;</span> f<span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">x</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> effect<span class="z-punctuation z-section z-group z-begin z-scala">(</span>println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog1</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> x zip x
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> effect<span class="z-punctuation z-section z-group z-begin z-scala">(</span>println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span> zip effect<span class="z-punctuation z-section z-group z-begin z-scala">(</span>println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></code></pre>
<p>In this example, we created a new, &quot;artificial&quot; type <code>Effectful[T]</code> (it's probably not a good idea to try
and come up with a type like this on your own). It describes a computation that will complete with a value of type <code>T</code>.
We gave it a method <code>zip</code> that will produce a new <code>Effectful</code> that will run two <code>Effectful</code> programs sequentially.</p>
<p>If we were to call <code>prog1.run()</code> or <code>prog2.run()</code>, you'd see that they behave identically - they'll both print <code>Foo</code> twice.</p>
<p>Thankfully, we don't need to come up with a type like this (and I don't recommend that you do - unless
you're absolutely sure the existing ones don't meet your needs).</p>
<p>There's plenty of competing options one can use in a similar way to how we used <code>Effectful</code> and <code>def effect</code>.
Here are a few that are the most popular in late 2018:</p>
<ul>
<li>cats-effect <code>IO[+A]</code></li>
<li>scalaz-zio <code>IO[+E, +A]</code></li>
<li>Monix <code>Task[+A]</code>.</li>
</ul>
<p>From the referential transparency/purity point of view, they behave in the same way - if we &quot;suspend&quot; side-effecting
operations using an operator that allows &quot;delaying&quot; a computation (for example, by taking a by-name parameter),
they'll give us the properties we need. One significant difference in the above is in terms of
error handling - <code>zio</code> allows an <code>IO</code> to fail with an error value of type <code>E</code> that you can specify on your own,
but the other two (cats-effect IO and Monix Task) only allow failure with values that extend <code>Throwable</code>.
Whether one solution has significant advantages over the other is a question for a different post ;)</p>
<p>All things considered, all of the above types support suspending synchronous effects (like printing to standard output,
or executing a JDBC call) and asynchronous, non-blocking effects (like communicating through HTTP or
listening for messages from Kafka). The main difference between these types and <code>Future</code> is that they are able to
<em>describe a computation</em> that can be ran at some point after they're defined, while <code>Future</code> is
a handle to an already running computation.</p>
<p>For the next part of the post, I'll use cats-effect's <code>IO</code>.</p>
<p>Let's recreate the printing example that we were able to make referentially transparent with <code>Effectful</code>:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-meta z-import z-scala"><span class="z-keyword z-other z-import z-scala">import</span> cats<span class="z-punctuation z-accessor z-dot z-scala">.</span>syntax<span class="z-punctuation z-accessor z-dot z-scala">.</span>apply<span class="z-punctuation z-accessor z-dot z-scala">.</span><span class="z-variable z-language z-underscore z-scala">_</span></span>
</span><span class="z-source z-scala"><span class="z-meta z-import z-scala"><span class="z-keyword z-other z-import z-scala">import</span> cats<span class="z-punctuation z-accessor z-dot z-scala">.</span>effect<span class="z-punctuation z-accessor z-dot z-scala">.</span>IO</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-comment z-block z-scala">/*
</span></span><span class="z-source z-scala"><span class="z-comment z-block z-scala"> * expands to `IO.apply(println(...))`,
</span></span><span class="z-source z-scala"><span class="z-comment z-block z-scala"> * defined as `def apply[T](f: =&gt; T): IO[T]`
</span></span><span class="z-source z-scala"><span class="z-comment z-block z-scala"> * `IO.apply` is equivalent to `IO.delay`
</span></span><span class="z-source z-scala"><span class="z-comment z-block z-scala"> */</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">x</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">IO</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog1</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span>x<span class="z-punctuation z-separator z-scala">,</span> x<span class="z-punctuation z-section z-group z-end z-scala">)</span></span><span class="z-punctuation z-accessor z-scala">.</span>tupled
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">prog2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-group z-scala"><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">IO</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-separator z-scala">,</span> <span class="z-support z-constant z-scala">IO</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span></span><span class="z-punctuation z-accessor z-scala">.</span>tupled
</span></code></pre>
<p>Again, running <code>prog1</code> and/or <code>prog2</code> will involve printing twice in each of them. That's why
we say IO is referentially transparent, or pure.</p>
<h2 id="a-word-on-determinism-and-io"><a class="zola-anchor" href="#a-word-on-determinism-and-io" aria-label="Anchor link for: a-word-on-determinism-and-io">A word on determinism and IO</a></h2>
<p>Earlier, I claimed that a function needs to return the same output for the same input. Would this be a function, then?</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">foo</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">IO</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-storage z-type z-primitive z-scala">Int</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">IO</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala">  <span class="z-support z-constant z-scala">Random</span><span class="z-punctuation z-accessor z-scala">.</span>nextInt<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>Some people would argue that it's not - because it's not deterministic. They argue that calling <code>foo</code> multiple times
will give you different results. But that's not true - just calling <code>foo</code> always gives you
the same action - nothing happens until you evaluate the IO. In fact, the whole function could be a constant:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">foo</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">IO</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-storage z-type z-primitive z-scala">Int</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">IO</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span> <span class="z-support z-constant z-scala">Random</span><span class="z-punctuation z-accessor z-scala">.</span>nextInt<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-punctuation z-section z-group z-end z-scala">)</span> <span class="z-punctuation z-section z-block z-end z-scala">}</span></span>
</span></code></pre>
<p>And as a constant it must be deterministic. The fact that evaluating it multiple times will give us different
results doesn't matter. One of the points of functions being deterministic is to allow storing them as values,
and reusing them. Take a look:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">foo</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">i</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-storage z-type z-primitive z-scala">Int</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">IO</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-storage z-type z-primitive z-scala">Unit</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span>
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">program</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> foo<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-constant z-numeric z-integer z-decimal z-scala">5</span><span class="z-punctuation z-section z-group z-end z-scala">)</span> *&gt; bar &lt;* foo<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-constant z-numeric z-integer z-decimal z-scala">5</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">program2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> baz &lt;* foo<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-constant z-numeric z-integer z-decimal z-scala">5</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></code></pre>
<p>Because all the calls to <code>foo</code> are the same, we can store the result of such a call and reuse it, while maintaining
the original behavior:</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">foo</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">i</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-storage z-type z-primitive z-scala">Int</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">IO</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-storage z-type z-primitive z-scala">Unit</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">foo5</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">IO</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-storage z-type z-primitive z-scala">Unit</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> foo<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-constant z-numeric z-integer z-decimal z-scala">5</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">program</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> foo5 *&gt; bar &lt;* foo5
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">program2</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> baz &lt;* foo5
</span></code></pre>
<p>&quot;How do we evaluate an IO?&quot;, you may ask. I'll respond, &quot;with <code>IOApp</code>&quot; (for example):</p>
<pre data-lang="scala" class="language-scala z-code"><code class="language-scala" data-lang="scala"><span class="z-source z-scala"><span class="z-meta z-import z-scala"><span class="z-keyword z-other z-import z-scala">import</span> cats<span class="z-punctuation z-accessor z-dot z-scala">.</span>effect<span class="z-punctuation z-accessor z-dot z-scala">.</span><span class="z-variable z-language z-underscore z-scala">_</span></span>
</span><span class="z-source z-scala"><span class="z-meta z-import z-scala"><span class="z-keyword z-other z-import z-scala">import</span> cats<span class="z-punctuation z-accessor z-dot z-scala">.</span>implicits<span class="z-punctuation z-accessor z-dot z-scala">.</span><span class="z-variable z-language z-underscore z-scala">_</span></span>
</span><span class="z-source z-scala">
</span><span class="z-source z-scala"><span class="z-meta z-class z-identifier z-scala"><span class="z-storage z-type z-class z-scala">object</span><span class="z-entity z-name z-class z-scala"> Main</span></span> <span class="z-keyword z-declaration z-scala">extends</span> <span class="z-entity z-other z-inherited-class z-scala">IOApp</span> <span class="z-meta z-class z-body z-scala"><span class="z-punctuation z-section z-braces z-begin z-scala">{</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala">  <span class="z-storage z-type z-function z-scala">def</span> <span class="z-entity z-name z-function z-scala">run</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-variable z-parameter z-scala">args</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">List</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">String</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-ascription z-scala">:</span> <span class="z-support z-class z-scala">IO</span><span class="z-punctuation z-definition z-generic z-begin z-scala">[</span><span class="z-support z-class z-scala">ExitCode</span><span class="z-punctuation z-definition z-generic z-end z-scala">]</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-meta z-block z-scala"><span class="z-punctuation z-section z-block z-begin z-scala">{</span>
</span></span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala"><span class="z-meta z-block z-scala">    <span class="z-storage z-type z-stable z-scala">val</span> <span class="z-variable z-other z-constant z-scala">foo</span> <span class="z-keyword z-operator z-assignment z-scala">=</span> <span class="z-support z-constant z-scala">IO</span><span class="z-punctuation z-section z-group z-begin z-scala">(</span>println<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-string z-quoted z-double z-scala"><span class="z-punctuation z-definition z-string z-begin z-scala">&quot;</span>Foo<span class="z-punctuation z-definition z-string z-end z-scala">&quot;</span></span><span class="z-punctuation z-section z-group z-end z-scala">)</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala"><span class="z-meta z-block z-scala">
</span></span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala"><span class="z-meta z-block z-scala">    foo *&gt; foo *&gt; foo
</span></span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala"><span class="z-meta z-block z-scala">  <span class="z-punctuation z-section z-block z-end z-scala">}</span></span><span class="z-punctuation z-accessor z-scala">.</span>as<span class="z-punctuation z-section z-group z-begin z-scala">(</span><span class="z-support z-constant z-scala">ExitCode</span><span class="z-punctuation z-accessor z-scala">.</span><span class="z-support z-constant z-scala">Success</span><span class="z-punctuation z-section z-group z-end z-scala">)</span>
</span></span><span class="z-source z-scala"><span class="z-meta z-class z-body z-scala"><span class="z-punctuation z-section z-braces z-end z-scala">}</span></span>
</span></code></pre>
<h2 id="thanks-for-reading"><a class="zola-anchor" href="#thanks-for-reading" aria-label="Anchor link for: thanks-for-reading">Thanks for reading</a></h2>
<p>I hope that you liked this not-so-short explanation of pure functions and that you'll benefit from it as much as me
and other people who believe in functional programming. If you still have any questions,
feel free to reach out to me in the comments or through my Twitter/email :)</p>
<p>If you think this post helped you, please share it on Twitter/Reddit/whatever you like. And while you're at it,
please leave a comment ;)</p>
<p>If you want to keep an eye out for the next thing I write, follow me and I'll make sure
you don't miss anything readworthy.</p>
<h2 id="links"><a class="zola-anchor" href="#links" aria-label="Anchor link for: links">Links</a></h2>
<p>To learn more about referential transparency, first-class effects and IO,
check out <a rel="noopener" target="_blank" href="https://typelevel.org/cats-effect/docs/getting-started">the documentation of cats.effect.IO</a>,
or <a rel="noopener" target="_blank" href="https://www.reddit.com/r/scala/comments/8ygjcq/can_someone_explain_to_me_the_benefits_of_io/e2jfp9b">Fabio Labella's comments in this Reddit thread</a>.
You may also want to see <a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=X-cEGEJMx_4">Luka Jacobowitz's talk about the other benefits of RT</a>,
<a rel="noopener" target="_blank" href="https://www.youtube.com/watch?v=po3wmq4S15A">Rob Norris's introduction to Effects</a>
and <a rel="noopener" target="_blank" href="https://vimeo.com/294736344">Fabio's talk about shared mutable state in pure FP</a>.</p>
<p>If you don't mind seeing a bunch of slides without an audible explanation,
you can also check out <a rel="noopener" target="_blank" href="https://kubukoz.github.io/talks/incremental-purity/slides">the slides for my latest talk</a>,
but sooner or later I'm planning to have it recorded and the video published.</p>
<p>For examples with ZIO, see <a rel="noopener" target="_blank" href="https://scalaz.github.io/scalaz-zio/usage/purity.html">ZIO's page on purity</a>.</p>
<p>I also recommend following <a rel="noopener" target="_blank" href="https://typelevel.org/blog/">the Typelevel blog</a> and
chatting to folks who love FP on <a rel="noopener" target="_blank" href="https://gitter.im/typelevel/cats">the cats gitter</a> and
<a rel="noopener" target="_blank" href="https://gitter.im/typelevel/cats-effect">other</a> related <a rel="noopener" target="_blank" href="https://gitter.im/typelevel/general">rooms</a>.</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date"> 2 December 2018</div>
        
        <div class="article-taxonomies">
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://blog.kubukoz.com/tags/scala/">#scala</a></li>
                    
                    <li><a href="https://blog.kubukoz.com/tags/functional-programming/">#functional programming</a></li>
                    
                    <li><a href="https://blog.kubukoz.com/tags/cats/">#cats</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


<div id="disqus_thread"></div>
<script>
  /**
   *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
   *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */

  var disqus_config = function () {
    this.page.url = "https://blog.kubukoz.com/what-makes-a-function-pure";
    this.page.identifier = '/what-makes-a-function-pure';
  };

  (function () {
    // DON'T EDIT BELOW THIS LINE
    var d = document,
      s = d.createElement("script");
    s.src = "https://kubukoz-blog.disqus.com/embed.js";
    s.setAttribute("data-timestamp", +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>
 
        </main>
        <footer>
            <p>
                ¬© Jakub Koz≈Çowski (<a href="https://twitter.com/kubukoz">@kubukoz</a>) 2025<br>
                Powered by <a target="_blank" href="https://getzola.org/">Zola</a>, Theme <a target="_blank" href="https://github.com/zbrox/anpu-zola-theme">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>
<!-- Google Analytics Tracking code -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-55943015-8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-55943015-8');
</script>

<script type="text/javascript" src="https://blog.kubukoz.com/elasticlunr.min.js"></script>
<script type="text/javascript" src="https://blog.kubukoz.com/search_index.en.js"/></script>
<script type="text/javascript" src="https://blog.kubukoz.com/search.js"/></script>
</html>
